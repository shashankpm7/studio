// use server'
'use server';
/**
 * @fileOverview AI-Powered Vulnerability Detection flow.
 *
 * This file defines a Genkit flow that leverages AI to scan smart contract code
 * for potential vulnerabilities. It takes smart contract code as input and
 * returns a detailed report of identified vulnerabilities, their severity,
 * and recommendations for remediation.
 *
 * @interface AiPoweredVulnerabilityDetectionInput - Defines the input schema for the flow.
 * @interface AiPoweredVulnerabilityDetectionOutput - Defines the output schema for the flow.
 * @function aiPoweredVulnerabilityDetection - The main function to trigger the vulnerability detection flow.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

/**
 * @interface AiPoweredVulnerabilityDetectionInput
 * @description Defines the input schema for the AI-powered vulnerability detection flow.
 * @property {string} smartContractCode - The smart contract code to be scanned. MUST be valid code.
 * @property {string} blockchainType - The blockchain type of the smart contract (e.g., ETH, SOL, ETC).
 */
const AiPoweredVulnerabilityDetectionInputSchema = z.object({
  smartContractCode: z.string().describe('The smart contract code to be scanned.'),
  blockchainType: z.string().describe('The blockchain type of the smart contract (e.g., ETH, SOL, ETC).'),
});
export type AiPoweredVulnerabilityDetectionInput = z.infer<typeof AiPoweredVulnerabilityDetectionInputSchema>;

/**
 * @interface AiPoweredVulnerabilityDetectionOutput
 * @description Defines the output schema for the AI-powered vulnerability detection flow.
 * @property {string} vulnerabilityReport - A detailed report of identified vulnerabilities, their potential impact, and actionable recommendations for remediation.
 */
const AiPoweredVulnerabilityDetectionOutputSchema = z.object({
  vulnerabilityReport: z.string().describe('A detailed report of identified vulnerabilities, their potential impact, and actionable recommendations for remediation.'),
});
export type AiPoweredVulnerabilityDetectionOutput = z.infer<typeof AiPoweredVulnerabilityDetectionOutputSchema>;

/**
 * aiPoweredVulnerabilityDetection
 * @description An async function that takes smart contract code as input, calls the aiPoweredVulnerabilityDetectionFlow to generate a vulnerability report, and returns the report.
 * @param {AiPoweredVulnerabilityDetectionInput} input - The input for the vulnerability detection flow, including the smart contract code and blockchain type.
 * @returns {Promise<AiPoweredVulnerabilityDetectionOutput>} - A promise that resolves to the vulnerability report.
 */
export async function aiPoweredVulnerabilityDetection(input: AiPoweredVulnerabilityDetectionInput): Promise<AiPoweredVulnerabilityDetectionOutput> {
  return aiPoweredVulnerabilityDetectionFlow(input);
}

const aiPoweredVulnerabilityDetectionPrompt = ai.definePrompt({
  name: 'aiPoweredVulnerabilityDetectionPrompt',
  input: {schema: AiPoweredVulnerabilityDetectionInputSchema},
  output: {schema: AiPoweredVulnerabilityDetectionOutputSchema},
  prompt: [
    'You are a smart contract security expert. Your task is to analyze the given smart contract code for potential vulnerabilities and generate a comprehensive report.',
    '',
    'Identify common vulnerabilities such as reentrancy, integer overflow, gas limit issues, and any other potential security flaws.',
    '',
    'Explain the potential impact of each vulnerability and provide actionable recommendations for remediation. Be specific with line numbers and code snippets where possible.',
    '',
    'Smart Contract Code:',
    '```',
    '{{{smartContractCode}}}',
    '```',
    '',
    'Blockchain Type: {{{blockchainType}}}',
    '',
    'Vulnerability Report:',
  ].join('\n'),
});

const aiPoweredVulnerabilityDetectionFlow = ai.defineFlow(
  {
    name: 'aiPoweredVulnerabilityDetectionFlow',
    inputSchema: AiPoweredVulnerabilityDetectionInputSchema,
    outputSchema: AiPoweredVulnerabilityDetectionOutputSchema,
  },
  async input => {
    const {output} = await aiPoweredVulnerabilityDetectionPrompt(input);
    return output!;
  }
);
